https://github.com/DonatasNoreika/python1lygis/wiki/Funkcijos


# `Functional programming`

As on [Wikipedia](https://en.wikipedia.org/wiki/Functional_programming):


'In computer science, functional programming is a programming paradigm where programs are constructed by applying and composing functions. It is a declarative programming paradigm in which function definitions are trees of expressions that map values to other values, rather than a sequence of imperative statements which update the running state of the program.'


In this section We will pay more attention on some functions already supplied by python programming language to make our lives a bit easier. The things we are going to cover here are also useful for OOP paradigms as well. 

In Python in general everything is an **`object`**, thus functions do escape this either. Functions can be assigned to have other names etc.

```python
def say_hello() -> None:
  print("hello")

greet = say_hello

greet() # print 'hello'
```

So as you can se it behaves in the same fashion as some string or integer or any other object. To go even one step beyond we can do something like this:

```python
def say_hello() -> None:
  print("hello")

my_list = [1, say_hello, "something"]
for item in my_list:
  print(item)

# 1
# <function say_hello at 0x00000251F1AAF4C0>
# somethin
```


We can even take it one step further
```python
from collections.abc import Callable

def say_hello() -> None:
  print("hello")

def another_function(f: Callable) -> None:
  f()

another_function(say_hello)
```

Try to stop here and make sure we understand what is going on. Can someone from class explain it to the others?

When you pass a function to another function, the passed-in function sometimes is referred to as a **`callback`** because a call back to the inner function can modify the outer function‚Äôs behavior.


So it happens so that functions can also be arguments for other functions ü§Ø ! ! ! You will learn much more about this in the Decorator subject that are going to cover further in this course. But for now you can see that functions in python is pretty wide topic, there are plenty of possibilities here.

But wait! There's more! as you can pass functions into another functions, functions can also return other functions!


```python
def outer():
    def inner():
        print("I am function inner()!")

    # Function outer() returns function inner()
    return inner


function = outer()
print(function)
# <function outer.<locals>.inner at 0x7f18bc85faf0>
function()
# I am function inner()!

outer()()
# I am function inner()!

```


## sorted function

We have already seen this function in action in the beginning of the course.

```python
animals = ["ferret", "vole", "dog", "gecko"]
sorted(animals)
# ['dog', 'ferret', 'gecko', 'vole']
```

This is already something that we have seen, but sorted function [documentation](https://docs.python.org/3/library/functions.html#sorted) says that there might be another parameter passed into the function - key. _key specifies a function of one argument that is used to extract a comparison key from each element in iterable (for example, key=str.lower). The default value is None (compare the elements directly)._

So this key parameter accepts a callable and then tried to sort our data according to it:

```python
animals = ["ferret", "vole", "dog", "gecko"]
sorted(animals, key=len)
# ['dog', 'vole', 'gecko', 'ferret']
```



## Lambda functions


We have already had an intro to lambdas [here](https://github.com/CodeAcademy-Online/python-new-material/wiki/Lesson-11:-Functions-(-Part-2-))
Functional programming is all about calling functions and passing them around, so it naturally involves defining a lot of functions. You can always define a function in the usual way, using the [def](https://realpython.com/defining-your-own-python-function/#function-calls-and-definition) keyword as you have seen in previous tutorials in this series.

Sometimes, though, it‚Äôs convenient to be able to define an anonymous function on the fly, without having to give it a name. In Python, you can do this with a lambda expression.

for a reminder, The syntax of a lambda expression is as follows:

```python
lambda <parameter_list>: <expression>
```

| Column 1 Header | Column 2 Header |
| :--------------- | :--------------- |
| lambda | The keyword that introduces a lambda expression |
| <parameter_list> | An optional comma-separated list of parameter names |
| : | Punctuation that separates <parameter_list> from <expression> |
| expression| An expression usually involving the names in¬†<parameter_list> |

So let's continue now a bit on lambda functions. Let's say we want to define lambda function that returns string in reverse:

```python
reverse = lambda s: s[::-1]
reverse("I am a string")
# 'gnirts a ma I'
```

This is actually the equivalent of:

```python
def reverse(s):
    return s[::-1]


reverse("I am a string")
# 'gnirts a ma I'


reverse = lambda s: s[::-1]
reverse("I am a string")
# 'gnirts a ma I'

```

As you can see they both yield the same result.
What is more as you have already seen it is not necessary to assign lambda function a name, you can also call it directly:

```python
(lambda s: s[::-1])("I am a string")
# 'gnirts a ma I'
```

One more example:

```python
(lambda x1, x2, x3: (x1 + x2 + x3) / 3)(9, 6, 6)
# 7.0
(lambda x1, x2, x3: (x1 + x2 + x3) / 3)(1.4, 1.1, 0.5)
# 1.0
```

Is it clear what is happening here? can anyone in the class explain the code?


Now let's go back into the `sorted` function we have seen already. since lambda gives us `callable`:

```python
callable(lambda s: s[::-1])
# True
```

**NOTE** ‚ùó  callable: Return `True` if the object argument appears callable, `False` if not.


reviewing our code from before:
```python
animals = ["ferret", "vole", "dog", "gecko"]

def reverse_len(string: str) -> int:
    return -len(string)

sorted(animals, key=reverse_len)
# ['ferret', 'gecko', 'vole', 'dog']
```

This could be changed with lambda function:

```python
animals = ["ferret", "vole", "dog", "gecko"]
sorted(animals, key=lambda s: -len(s))
# ['ferret', 'gecko', 'vole', 'dog']
```


Looks a little bit more compact and is still quite readable right? As any things in programming or life both approaches have up and down sides. Discuss the advantages and disadvanates of both approaches.



**NOTE** ‚ùó  you can only define fairly rudimentary functions with lambda. The return value from a lambda expression can only be one single expression. A lambda expression can‚Äôt contain statements like assignment or return, nor can it contain control structures such as for, while, if, else, or def.

As we have seen before functions in python can return anything:

```python
def func(x):
    return x, x ** 2, x ** 3

func(2)
# (2, 4, 16)
```

In this case we simply return Tuple. Does anyone remember what Tuple is? what are the specifics?
Let's say we try to do the same with lambda functions:

```python
(lambda x: x, x ** 2, x ** 3)(3)
<stdin>:1: SyntaxWarning: 'tuple' object is not callable; perhaps you missed a comma?
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'x' is not defined
```

To work with this is all you got to do is explicitly tell python that this is a Tuple object that we are returning:

```python
(lambda x: (x, x ** 2, x ** 3))(3)
# (3, 9, 27)
(lambda x: [x, x ** 2, x ** 3])(3)
# [3, 9, 27]
(lambda x: {1: x, 2: x ** 2, 3: x ** 3})(3)
# {1: 3, 2: 9, 3: 27}
```

As you can see there might be plenty of variations of what **lambda functions** can return.


One more final detail: If you find a need to include a lambda expression in a formatted string literal (f-string), then you‚Äôll need to enclose it in explicit parentheses:

```python
print(f"--- {lambda s: s[::-1]} ---")
  File "<stdin>", line 1
    (lambda s)
             ^
SyntaxError: f-string: invalid syntax
```

Do this instead:
```python
print(f"--- {(lambda s: s[::-1])} ---")
# --- <function <lambda> at 0x7f97b775fa60> ---
print(f"--- {(lambda s: s[::-1])('I am a string')} ---")
# --- gnirts a ma I ---
```


# Map function

The first function on the docket is map(), which is a Python built-in function. With map(), you can apply a function to each element in an iterable in turn, and map() will return an iterator that yields the results. This can allow for some very concise code because a map() statement can often take the place of an explicit loop.

Syntax:

```python
map(<f>, <iterable>)
```

Let's revisit our function:
```python
def reverse(s):
    return s[::-1]

reverse("I am a string")
```

If you have a list of strings, then you can use map() to apply reverse() to each element of the list:


```python
animals = ["cat", "dog", "hedgehog", "gecko"]
iterator = map(reverse, animals)
iterator
# <map object at 0x7fd3558cbef0>
```


**NOTE** ‚ùó ‚ùó ‚ùó But remember, map() doesn‚Äôt return a list. It returns an iterator called a map object. To obtain the values from the iterator, you need to either iterate over it or use list():

```python
animals = ["cat", "dog", "hedgehog", "gecko"]
def reverse(s):
    return s[::-1]

iterator = map(reverse, animals)
for i in iterator:
    print(i)
# tac
# god
# gohegdeh
# okceg

iterator = map(reverse, animals)
list(iterator)

```


Let's take it further once more, we already know that lambdas give us a function, let's try passing it to map function:

```python
animals = ["cat", "dog", "hedgehog", "gecko"]
iterator = map(lambda s: s[::-1], animals)
list(iterator)
# ['tac', 'god', 'gohegdeh', 'okceg']
```

Let's even do it a more compact way:

```python
list(map(lambda s: s[::-1], ["cat", "dog", "hedgehog", "gecko"]))
# ['tac', 'god', 'gohegdeh', 'okceg']
```

If the iterable contains something that is not suitable for a certain operation:

```python
list(map(lambda s: s[::-1], ["cat", "dog", 3.14159, "gecko"]))
# Traceback (most recent call last):
#  File "<stdin>", line 1, in <module>
#  File "<stdin>", line 1, in <lambda>
# TypeError: 'float' object is not subscriptable
```

In this case, the lambda function expects a string argument, which it tries to slice. The second element in the list, 3.14159, is a float object, which isn‚Äôt sliceable. So a TypeError occurs.


## Calling map with multiple iterables

```python
map(<f>, <iterable‚ÇÅ>, <iterable‚ÇÇ>, ..., <iterable‚Çô>)
```

The number of <iterablei> arguments specified to map() must match the number of arguments that <f> expects. <f> acts on the first item of each <iterablei>, and that result becomes the first item that the return iterator yields. Then <f> acts on the second item in each <iterablei>, and that becomes the second yielded item, and so on.

```python
def f(a, b, c):
    return a + b + c


list(map(f, [1, 2, 3], [10, 20, 30], [100, 200, 300]))
# [111, 222, 333]
```
Here is more visual representation of how the calculation is being done:
![IMG](https://github.com/CodeAcademy-Online/python-new-material-level2/blob/master/images/map.webp)



# filter function

filter() allows you to select or filter items from an iterable based on evaluation of the given function. It‚Äôs called as follows:

```python
filter(<f>, <iterable>)
```


filter(<f>, <iterable>) applies function <f> to each element of <iterable> and returns an iterator that yields all items for which <f> is truthy. Conversely, it filters out all items for which <f> is falsy.

```python
def greater_than_100(x):
    return x > 100

list(filter(greater_than_100, [1, 111, 2, 222, 3, 333]))
# [111, 222, 333]
```

As we see that function is the first argument, let's try applying lambdas function here.


```python
list(filter(lambda x: x > 100, [1, 111, 2, 222, 3, 333]))
```

What is more we can even combine there things with range() function - range(n) produces an iterator that yields the integers from 0 to n - 1. The following example uses filter() to select only the even numbers from the list and filter out the odd numbers:


```python
list(range(10))
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
def is_even(x):
    return x % 2 == 0

list(filter(is_even, range(10)))
# [0, 2, 4, 6, 8]

list(filter(lambda x: x % 2 == 0, range(10)))
# [0, 2, 4, 6, 8]

```

Can we do that with strings as well? As long as we have  a correct function that returns `True` or `False` based on string input - Yes!

```python
animals = ["cat", "Cat", "CAT", "dog", "Dog", "DOG", "emu", "Emu", "EMU"]

def all_caps(s):
    return s.isupper()

list(filter(all_caps, animals))
# ['CAT', 'DOG', 'EMU']

list(filter(lambda s: s.isupper(), animals))
# ['CAT', 'DOG', 'EMU']
```


# Reduce function

reduce() applies a function to the items in an iterable two at a time, progressively combining them to produce a single result.

To use reduce(), you need to import it from a module called functools. This is possible in several ways, but the following is the most straightforward:


```python
from functools import reduce
```

## Calling reduce with two arugments:

```python
reduce(<f>, <iterable>)
```

reduce(<f>, <iterable>) uses <f>, which must be a function that takes exactly two arguments, to progressively combine the elements in <iterable>. To start, reduce() invokes <f> on the first two elements of <iterable>. That result is then combined with the third element, then that result with the fourth, and so on until the list is exhausted. Then reduce() returns the final result.

let's start with some simple examples:


```python
def f(x, y):
    return x + y


from functools import reduce
reduce(f, [1, 2, 3, 4, 5])
# 15
```

Here is a representation of what is happening behind the scenes when `reduce` is called:

![IMG](https://github.com/CodeAcademy-Online/python-new-material-level2/blob/master/images/reduce.webp)

reduce is quite disliked function even by the python creator Guido van Rossum:

_So now reduce(). This is actually the one I‚Äôve always hated most, because, apart from a few examples involving + or *, almost every time I see a reduce() call with a non-trivial function argument, I need to grab pen and paper to diagram what‚Äôs actually being fed into that function before I understand what the reduce() is supposed to do. So in my mind, the applicability of reduce() is pretty much limited to associative operators, and in all other cases it‚Äôs better to write out the accumulation loop explicitly. ([Source](https://www.artima.com/weblogs/viewpost.jsp?thread=98196))_

Even in our example we can see that there are simpler ways of doing our simple example. Can you suggest any of them? Discuss

The most simple one would probably be:
```python
sum([1, 2, 3, 4, 5])
```

Now let's use multiplication operator (*) to find a factorial of some number. [What is a factorial](https://www.mathsisfun.com/numbers/factorial.html)

```python
def multiply(x, y):
    return x * y


def factorial(n):
    from functools import reduce
    return reduce(multiply, range(1, n + 1))


factorial(4)  # 1 * 2 * 3 * 4

factorial(6)  # 1 * 2 * 3 * 4 * 5 * 6
```


Yet there is a quite simpler example on how to do this:
```python
from math import factorial

factorial(4)

factorial(6)
```


We could also use reduce to get the same result as max() does:

```python
max([23, 49, 6, 32])


def greater(x, y):
    return x if x > y else y


from functools import reduce
reduce(greater, [23, 49, 6, 32])
```

## Calling reduce() with initial value

```python
reduce(<f>, <iterable>, <init>)
```

When present, <init> specifies an initial value for the combination. In the first call to <f>, the arguments are <init> and the first element of <iterable>. That result is then combined with the second element of <iterable>, and so on:
```python
def f(x, y):
    return x + y


from functools import reduce
reduce(f, [1, 2, 3, 4, 5], 100)  # (100 + 1 + 2 + 3 + 4 + 5)
```

The graphical visualization of the actions taken:


![IMG](https://github.com/CodeAcademy-Online/python-new-material-level2/blob/master/images/reduce2.webp)


As you‚Äôve seen in the above examples, even in cases where you can accomplish a task using reduce(), it‚Äôs often possible to find a more straightforward and Pythonic way to accomplish the same task without it. Maybe it‚Äôs not so hard to imagine why reduce() was removed from the core language after all.

That said, reduce() is kind of a remarkable function. The description at the beginning of this section states that reduce() combines elements to produce a single result. But that result can be a composite object like a list or a tuple. For that reason, reduce() is a very generalized higher-order function from which many other functions can be implemented.

For example, you can implement map() in terms of reduce():

```python
numbers = [1, 2, 3, 4, 5]

list(map(str, numbers))


def custom_map(function, iterable):
    from functools import reduce

    return reduce(
        lambda items, value: items + [function(value)],
        iterable,
        [],
    )

print(list(custom_map(str, numbers)))
```

In fact, any operation on a sequence of objects can be expressed as a reduction.

## Exercises: üß† 


**Lambdas section**: 

1. Write a Python program to create a lambda function that adds 15 to a given number passed in as an argument, also create a lambda function that multiplies argument x with argument y and print the result.

1. Write a Python program to add two given lists using map and lambda.
1. Write a Python program to square and cube every number in a given list of integers using Lambda
1. Write a Python program to extract year, month, date and time using Lambda. Sample Output:
2020-01-15 09:03:32.744178
2020
1
15
09:03:32.744178
1.  


**Lambdas section**: 


**Lambdas section**: 



**Lambdas section**: 



**Lambdas section**: 
# üåê Extra reading:

* [Python documentation on functional programming](https://docs.python.org/3/howto/functional.html#:~:text=Functional%20programming%20wants%20to%20avoid,%2C%20transactions%2C%20etc.).)

* [iterators](https://realpython.com/python-for-loop/#iterators)

* [real python on functional programming](https://realpython.com/python-functional-programming/#what-is-functional-programming)

